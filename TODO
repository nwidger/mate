#    -*- mode: org -*-
#+STARTUP: overview
#+STARTUP: hidestars
#
# Niels Widger
# Time-stamp: <17 Sep 2013 at 18:38:25 by nwidger on macros.local>

* mc
* mas
* mvm
** is it okay to use an object pointer in table_XXX and then use it after returning 
   from a function that may have dmp_thread_block'd?  I.e. entry pointer in table_get
   for loop after table_run_equals
** run actual getfield/aload instruction functions to get/set table fields
* mdb
* spec
* general

* evaluation
** quantum sizes: 1000, 10000 and 100000
** full and reduced serial mode
** ownership table granularity - 1, 5 and 10 depth
** 2, 4, 8 and 16 threads

1,000 instruction quantum, full serial mode, 1 ownership table depth	   = -p  -Q1000 -g1
1,000 instruction quantum, full serial mode, 5 ownership table depth	   = -p  -Q1000 -g5
1,000 instruction quantum, full serial mode, 10 ownership table depth	   = -p  -Q1000 -g10
1,000 instruction quantum, reduced serial mode, 1 ownership table depth	   = -pr -Q1000 -g1
1,000 instruction quantum, reduced serial mode, 5 ownership table depth	   = -pr -Q1000 -g5
1,000 instruction quantum, reduced serial mode, 10 ownership table depth   = -pr -Q1000 -g10

10,000 instruction quantum, full serial mode, 1 ownership table depth      = -p  -Q10000 -g1	 
10,000 instruction quantum, full serial mode, 5 ownership table depth	   = -p  -Q10000 -g5	
10,000 instruction quantum, full serial mode, 10 ownership table depth	   = -p  -Q10000 -g10
10,000 instruction quantum, reduced serial mode, 1 ownership table depth   = -pr -Q10000 -g1
10,000 instruction quantum, reduced serial mode, 5 ownership table depth   = -pr -Q10000 -g5
10,000 instruction quantum, reduced serial mode, 10 ownership table depth  = -pr -Q10000 -g10

100,000 instruction quantum, full serial mode, 1 ownership table depth     = -p  -Q100000 -g1	
100,000 instruction quantum, full serial mode, 5 ownership table depth	   = -p  -Q100000 -g5	
100,000 instruction quantum, full serial mode, 10 ownership table depth	   = -p  -Q100000 -g10
100,000 instruction quantum, reduced serial mode, 1 ownership table depth  = -pr -Q100000 -g1
100,000 instruction quantum, reduced serial mode, 5 ownership table depth  = -pr -Q100000 -g5
100,000 instruction quantum, reduced serial mode, 10 ownership table depth = -pr -Q100000 -g10

* outline

** abstract

** introduction

*** thesis goals

*** outline

** background

*** previous work

**** deterministic shared memory multiprocessing (dmp)

**** coredet

**** kendo

**** grace

**** deterministic parallel java

** implementation

*** language work

    for loop, >=, <=, !=, && and || operators

    predefined class class, both compiler and VM parse it to load
    predefined classes, their methods and determine their native
    method indices

*** real class

*** threading model

**** VM work

***** linux cpu affinity (for dmp)

***** integer/string cache

***** per-thread object ref cache

***** reduce usage of mutex's in VM structs to improve multithreaded performance

***** add monitor to each object using nlocks and new monitorenter/monitorexit instructions

**** language work

***** thread class

***** wait/notify object methods

***** synchronized blocks

*** dmp

**** overall desgin

     each object gets own dmp struct with function pointers for each hook

**** object dmp

     object_dmp_load, object_dmp_store, object_dmp_chown

**** thread dmp

     thread_dmp_thread_creation, thread_dmp_thread_start,
     thread_dmp_thread_destruction, thread_dmp_thread_join,
     thread_dmp_thread_sleep, thread_dmp_execute_instruction

**** nlock dmp

     nlock_dmp_default_lock, nlock_dmp_default_unlock,
     nlock_dmp_default_timedwait

**** table_dmp

     table_dmp_load, table_dmp_store

     discuss attempt to implement table entirely with objects

**** dmp stats -D option

** results

*** tests performed

**** radix sort

**** jacobi

**** DPL boolean satisfiabilty

** conclusion

*** future work
