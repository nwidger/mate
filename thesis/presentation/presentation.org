#    -*- mode: org -*-
#+STARTUP: hidestars
#+STARTUP: overview
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_HLEVEL: 999
#+REVEAL_EXTRA_CSS: ./presentation.css
# Time-stamp: <08 Dec 2013 at 13:53:35 by nwidger on macros.local>

#+TITLE: Deterministic Execution in a Java-like Language
#+AUTHOR: Niels Widger
#+EMAIL: niels.widger@unh.edu

* Thesis

  A Java-like programming language can be executed deterministically
  using DMP with less overhead than a C-like programming language.

* Background

** Multithreaded programming is /hard!/
   
   -----
   
  1. Concurrency bugs
     
     /reproducible?/
     
  2. Unit testing
     
     /test all inputs/
     
     /test each input X times/
     
  3. Crash reports
     
     /usefullness?/

** Source of problems?

   -----

   Nondeterminism!

** Thread Interleavings

   #+ATTR_HTML: :width 100%
   | thread 1 | thread 2 |
   |----------+----------|
   | load     |          |
   | store    |          |
   |          | load     |
   | *load*   | *store*  |
   | store    |          |
   |          | load     |
   | load     |          |
   | store    | store    |

** Why do thread interleavings change?

   + OS scheduler

   + Cache state

   + I/O delays

** Can we make execution deterministic?

   + Multithreaded program

   + Threads communicate via shared memory

   + Produces same output when given the same input

** Naive Deterministic Execution

   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/naive.png]]

   #+BEGIN_NOTES
   -Force exact same thread interleaving for every execution!
   -Generate interleaving by serializing execution, allowing each thread to execute N instructions called a QUANTUM
   #+END_NOTES

** Deterministic Execution Achieved

   But can we do better?

** Deterministic Shared Multiprocessing

   + Dynamic *run-time* enforcement of deterministic

   + Guarantees deterministic ordering of all *shared memory accesses*
     for a given input.

   + Arbitrary code

   + *Without* sacrificing performance

** How does it work?

   + Execute non-communicating instructions in parallel

     + Recover parallelism

     + Without interthread communication, thread interleaving does not
       affect program output

   + Serialize execution during interthread communication

** Communicating Instructions

   + Load/store instructions to shared memory

   + Modify behavior of other threads

   + Enforce ordering of communicating instructions, others do not
     matter

** Quanta

   + Split in two:

     + Parallel mode

     + Serial mode

   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/quantum.png]]

   #+BEGIN_NOTES
   Threads allowed to execute in parallel until they attempt to communicate via a communicating instruction
   Communicating instruction delayed until serial mode
   Remainder of quantum budget executed in serial mode
   #+END_NOTES

** Ownership Table

   + Used to detect communicating instructions

   + Track ownership information for each memory location

     + Private - accessible only to owner

     + Shared - read-only by everyone

   + Access unrestricted in serial mode

   + Granularity - byte, word, page, etc.

   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/ownershippolicy.png]]

   #+BEGIN_NOTES
   -consult ownership table before each load/store instruction
   -defer interthread comm. Via comm. Instr. Until serial mode
   -changes to ownership table happen only in serial mode
   #+END_NOTES

** Ownership Graph

   /solid == proceed immediately, dotted == block until serial mode/

   [[./images/ownership-graph.png]]

** Previous DMP Implementations
   
   + CoreDet - DMP in software
   
     + Modified LLVM compiler instruments load/store instructions
      
     + Arbitrary =C=/=C++= code
      
     + Linked with run-time framework
      
     + Ownership table stored in shared memory
      
   + *Results:* Average slowdown of 1.1x - 6x

   + Good enough for debugging, maybe for deployment!

** DMP Summary

   + Execute arbitrary code deterministically

   + Deterministic ordering of communicating instructions

   + Detect interthread communication, defer until serial mode

   + Ownership table used to detect communicating instructions

** maTe

   1. Pure OO programming language

   2. Executed in virtual machine

   3. Grammar, instruction set and machine architecture heavily based
      on Java

   4. Originally single-threaded

** Architecture

   [[./images/vm-arch.png]]

   #+BEGIN_NOTES
   -references only == no pointers
   -method frames totally private
   -private == good == no need to instrument
   -other frames inaccessible to other frames or threads
   -no global variables â€“ object graph traversed using object fields
   #+END_NOTES

* maTe DMP

* Implementation

** Compiler Changes

*** =synchronized= blocks

   #+BEGIN_SRC java
     synchronized (obj) { x = obj.shared; }
   #+END_SRC

*** =Real= class (=float= wrapper)
 
   #+BEGIN_SRC java  
     class Real extends Object {
             native Real();
             native Real(Real r);
             native Real(Integer i);
             native Real add(Real r);
             native Real subtract(Real r);
             native Real multiply(Real r);
             native Real divide(Real r);
             native Real greaterThan(Real r);
             native Real lessThan(Real r);
             native Real greaterThanEqual(Real r);
             native Real lessThanEqual(Real r);
             native Integer not();
             native Real minus();
             native Real operator + (Real r);
             native Real operator - (Real r);
             native Real operator * (Real r);
             native Real operator / (Real r);
             native Integer operator > (Real r);
             native Integer operator < (Real r);
             native Integer operator >= (Real r);  
             native Integer operator <= (Real r);  
             native Integer operator ! ();
             native Real operator - ();
             native Integer equals(Object obj);
             native Integer hashCode();
             native String toString();
             native Real squareRoot();
     }
   #+END_SRC
   
*** =Thread= class

   #+BEGIN_SRC java
     class Thread extends Object {
             native Thread();
             native Object start();  // begin execution of run()
             native Object run();    // overridden by subclass
             native Object join();
             native Object sleep(Integer millisec);  
     }
   #+END_SRC
   
*** =Object= class =wait= / =notify= methods

   #+BEGIN_SRC java
     class Object {
             native Object notify();
             native Object notifyAll();
             native Object wait();
             native Object wait(Integer timeout);    
     }
   #+END_SRC

** Compiler Changes cont'd

   (aka things you take for granted)

*** =for= loops
   
   #+BEGIN_SRC java
     for (i = 0; i < 10; i = i + 1) { ... }
   #+END_SRC
   
*** =&&= and =||= operators
   
   #+BEGIN_SRC java
     if ((a && b) || (c && d)) { ... }
   #+END_SRC
   
*** =!==, =<==, =>== operators
   
   #+BEGIN_SRC java
     if (a != b) { ... }
     if (a <= b) { ... }
     if (a >= b) { ... }
   #+END_SRC

** Assembler Changes

   =monitorenter= / =monitorexit= instructions

** Multithreaded Architecture

   [[./images/vm-arch-mt.png]]

   #+BEGIN_NOTES
   -Each thread is allocated its own PC register and VM stack
   -Share same heap
   #+END_NOTES

** Virtual Machine Changes

*** Implementing Threads

    Each =Thread= gets its own VM stack

    Use =pthreads= threading library

    Use =pthreads_mutex_t= for object monitors

*** Implementing DMP

**** Goals

     Enable/disable *without* recompiling

     *Minimize* performance penalty when disabled

     Allow *per-object* or *per-thread* behavior

**** Design

     DMP-specific modules for =object=, =thread=, =nlock= (object
     monitor) and =table=.

     Global =dmp= module.

*** Example

    #+BEGIN_SRC c
      int object_create(struct class *c, uint32_t n, struct object **o) {
      #ifdef DMP
              if (dmp == NULL)
                      object->dmp = NULL;
              else
                      object->dmp = dmp_create_object_dmp(dmp, object);
      #endif
      }
    #+END_SRC

*** Object DMP
    
    #+BEGIN_SRC c
      int object_load_field(struct object *o, int i) {
      #ifdef DMP
              if (o->dmp != NULL)
                      object_dmp_load(o->dmp, i);
      #endif
      
              return o->fields[i];
      }
    #+END_SRC

*** Thread DMP

*** Table DMP

*** NLock DMP

*** DMP Statistics

*** Performance Enhancements

* Results

** Benchmarks

   + Parallel radix sort - Multithreaded radix sort

   + Jacobi - uses the Jacobi method to simulate temperature changes
     on a 20x25 plate

   + Parallel DPLL - Multithreaded boolean satisfiability using the
     DPLL algorithm
     
   #+BEGIN_NOTES
   Test test test
   #+END_NOTES

** Parameters

   + threads - 2, 4, 8 or 16 threads

   + quantum size - 1000, 10000, and 100000 instructions

   + full serial mode or reduced serial mode

   + ownership table granularity - 1, 5 and 10 depth

** Evaluation

   + overhead - measure difference in execution time when compared to
     a non-DMP virtual machine

   + measure difference in performance when parameters are changed

   Each benchmark was run 10 times for each combination of parameters.
   Run-times are averages.

** Radix

** Jacobi

** Parallel DPLL

* Conclusions

** Future Work
