#    -*- mode: org -*-
#+STARTUP: hidestars
#+STARTUP: overview
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_HLEVEL: 999
#+REVEAL_EXTRA_CSS: ./presentation.css
# Time-stamp: <08 Dec 2013 at 13:53:35 by nwidger on macros.local>

#+TITLE: Deterministic Execution in a Java-like Language
#+AUTHOR: Niels Widger
#+EMAIL: niels.widger@unh.edu

* Thesis

  A Java-like programming language can be executed deterministically
  using Deterministic Shared Multiprocessing (DMP) with less overhead
  than a C-like programming language.

* Background

** Deterministic Shared Multiprocessing

   + Dynamic *run-time* enforcement of deterministic

   + Guarantees *deterministic ordering of all shared memory accesses*
     for a given input.

   + Works on *arbitrary code*

   + Do so *without* sacrificing performance

** How does it work?

   + Execute non-communicating instructions in parallel

     + Recover parallelism

     + Without interthread communication, thread interleaving does not
       affect program output

   + Serialize execution during interthread communication

   -----

   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/quantum.png]]

   #+BEGIN_NOTES
   Thread given # of instructions to execute per quantum
   Threads allowed to execute in parallel until they attempt to communicate via a communicating instruction
   Communicating instruction delayed until serial mode
   Remainder of quantum budget executed in serial mode
   #+END_NOTES

** Communicating Instructions

   + Load/store instructions to shared memory

   + Modify behavior of other threads

   + Enforce ordering of communicating instructions, others do not
     matter

** Ownership Table

   + Used to detect communicating instructions

   + Track ownership information for each memory location

     + Private - accessible only to owner

     + Shared - read-only by everyone

   + Access unrestricted in serial mode

   + Granularity - byte, word, page, etc.

   -----
     
   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/ownershippolicy.png]]
   
   #+BEGIN_NOTES
   -consult ownership table before each load/store instruction
   -defer interthread comm. Via comm. Instr. Until serial mode
   -changes to ownership table happen only in serial mode
   #+END_NOTES

** Ownership Graph

   /solid == proceed immediately, dotted == block until serial mode/

   [[./images/ownership-graph.png]]

** Previous DMP Implementations
   
   + CoreDet - DMP in software
   
     + Modified LLVM compiler instruments load/store instructions
      
     + Arbitrary =C= / =C++= code
      
     + Linked with run-time framework
      
     + Ownership table stored in shared memory
      
   + *Results:* Average slowdown of 1.1x - 6x

   + Good enough for debugging, maybe for deployment!

** DMP Summary

   + Execute arbitrary code deterministically

   + Deterministic ordering of communicating instructions

   + Detect interthread communication in parallel mode, defer until
     serial mode

   + Ownership table used to detect communicating instructions

** maTe - a Java-like programming language

   1. Pure OO programming language

   2. Executed in virtual machine

   3. Grammar, instruction set and machine architecture heavily based
      on Java

   4. Single-threaded

** Architecture

   [[./images/vm-arch.png]]

   #+BEGIN_NOTES
   -references only == no pointers
   -method frames totally private
   -private == good == no need to instrument
   -other frames inaccessible to other frames or threads
   -no global variables â€“ object graph traversed using object fields
   #+END_NOTES

** maTe instruction set

   #+ATTR_HTML: :width 100%
   | =aconst_null= | =invokespecial= |
   | =aload=       | =invokenative=  |
   | =areturn=     | =invokevirtual= |
   | =astore=      | =new=           |
   | =checkcast=   | =newint=        |
   | =dup=         | =newstr=        |
   | =getfield=    | =out=           |
   | =goto=        | =putfield=      |
   | =ifeq=        | =refcmp=        |
   | =in=          | =return=        |

   #+BEGIN_NOTES
   Only two instructions can cause interthread communication
   Other instructions work on private op stack/local variable arrays
   #+END_NOTES

** maTe instruction set

   #+ATTR_HTML: :width 100%
   | =aconst_null= | =invokespecial= |
   | =aload=       | =invokenative=  |
   | =areturn=     | =invokevirtual= |
   | =astore=      | =new=           |
   | =checkcast=   | =newint=        |
   | =dup=         | =newstr=        |
   | *=getfield=*  | =out=           |
   | =goto=        | *=putfield=*    |
   | =ifeq=        | =refcmp=        |
   | =in=          | =return=        |

* Implementation

** Compiler Changes

   (aka things you take for granted)

   -----

   + =for= loops
   
   #+BEGIN_SRC java
     for (i = 0; i < 10; i = i + 1) { ... }
   #+END_SRC
   
   + Boolean =&&= and =||= operators
   
   #+BEGIN_SRC java
     if ((a && b) || (c && d)) { ... }
   #+END_SRC
   
   + =!==, =<== and =>== operators
   
   #+BEGIN_SRC java
     if (a != b) { ... }
     if (a <= b) { ... }
     if (a >= b) { ... }
   #+END_SRC

** Compiler Changes cont'd

*** =Real= class (=float= wrapper)
 
   #+BEGIN_SRC java  
     class Real extends Object {
             native Real();
             native Real(Real r);
             native Real(Integer i);
             native Real add(Real r);
             native Real subtract(Real r);
             native Real multiply(Real r);
             native Real divide(Real r);
             native Real greaterThan(Real r);
             native Real lessThan(Real r);
             native Real greaterThanEqual(Real r);
             native Real lessThanEqual(Real r);
             native Integer not();
             native Real minus();
             native Real operator + (Real r);
             native Real operator - (Real r);
             native Real operator * (Real r);
             native Real operator / (Real r);
             native Integer operator > (Real r);
             native Integer operator < (Real r);
             native Integer operator >= (Real r);  
             native Integer operator <= (Real r);  
             native Integer operator ! ();
             native Real operator - ();
             native Integer equals(Object obj);
             native Integer hashCode();
             native String toString();
             native Real squareRoot();
     }
   #+END_SRC

*** =synchronized= blocks

    #+BEGIN_SRC java
     for (i = 0; i < 10; i = i + 1) {
             synchronized (obj) {
                     if (obj.field != null) return obj.field;
             }
     }
    #+END_SRC

    -----
    
    + Use new =monitorenter= / =monitorexit= instructions

    + Monitor stack ensures necessary =monitorexit= instructions are
      executed for all execution paths.

   
*** =Thread= class

   #+BEGIN_SRC java
     class Thread extends Object {
             native Thread();
             native Object start();  // begin execution of run()
             native Object run();    // overridden by subclass
             native Object join();
             native Object sleep(Integer millisec);  
     }
   #+END_SRC

    -----

    + Java-based threading model
   
*** =Object= class =wait= / =notify= methods

   #+BEGIN_SRC java
     class Object {
             native Object notify();
             native Object notifyAll();
             native Object wait();
             native Object wait(Integer timeout);    
     }
   #+END_SRC

    -----

    + Asynchronous events

** Virtual Machine Changes

*** Multithreaded Architecture

   [[./images/vm-arch-mt.png]]

   #+BEGIN_NOTES
   -Each thread is allocated its own PC register and VM stack
   -Share same heap
   #+END_NOTES

*** Implementing Threads

    + Each =Thread= gets its own PC register & VM stack

    + Use =pthreads= threading library

    + Use =pthreads_mutex_t= for object monitors

*** Implementing DMP in maTe

    + Control execution of threads

    + Instrument =getfield= / =putfield= instructions

    + Track owner of each object

*** Design Goals

    + Enable/disable *without* recompiling

      #+BEGIN_SRC sh
        mvm myclass.class;    # DMP disabled
        mvm -p myclass.class; # DMP enabled
      #+END_SRC
    
    + *Minimize* performance penalty when disabled
    
    + Allow *per-object* or *per-thread* behavior

    + Compile virtual machine with all DMP code absent

      #+BEGIN_SRC sh
        ./configure --enable-dmp=no && make && sudo make install;
        mvm -p myclass.class
        Invalid switch option 'p'
      #+END_SRC

*** Design

     + Global =dmp= module.

     + DMP-specific modules for =object=, =thread=, =nlock= (object
       monitor) and =table=.

*** Global =dmp= module

    + Tracks blocked threads, wake them during serial mode

    -----

    #+BEGIN_SRC c
      int dmp_thread_block(struct dmp *d, struct thread_dmp *td);
    #+END_SRC

    + Maintain thread set in creation order for serial mode

    -----

    #+BEGIN_SRC c
      int dmp_add_thread(struct dmp *d, int r);
      int dmp_remove_thread(struct dmp *d, int r);
    #+END_SRC

    + Implements default ownership table policy

    -----

    #+BEGIN_SRC c
      int dmp_shm_read(struct dmp *d, int c, int r, enum dmp_thread_action *ta, enum dmp_owner_action *oa);
      int dmp_shm_write(struct dmp *d, int c, int r, enum dmp_thread_action *ta, enum dmp_owner_action *oa);
    #+END_SRC

    #+BEGIN_NOTES
    Before allowing a $getfield$ or $putfield$ to actually read/write
    an object's field, the DMP-specific $object$ module passes in the
    ID of the object it is going to access.  The $dmp$ module returns
    a $thread$ action ($block$ or $proceed$) and an $owner$ action
    ($none$, $set shared$ or $set private$) to perform.
    #+END_NOTES

    + Allocates DMP-specific modules for each =object=, =thread=,
      =table= and =nlock= instance

    -----

    #+BEGIN_SRC c
      struct object_dmp * dmp_create_object_dmp(struct dmp *d, struct object *o);
      struct thread_dmp * dmp_create_thread_dmp(struct dmp *d, struct thread *t);
      struct nlock_dmp * dmp_create_nlock_dmp(struct dmp *d, struct nlock *n);
      struct table_dmp * dmp_create_table_dmp(struct dmp *d, struct table *t, struct object_dmp *od);
    #+END_SRC

*** DMP-specific modules

    + =object=, =thread=, =table= and =nlock= instances store pointer
      to DMP-specific module instance
      
    #+BEGIN_SRC c
      int object_create(struct class *c, uint32_t n, struct object **o) {
      #ifdef DMP
              if (dmp == NULL)
                      object->dmp = NULL;
              else
                      object->dmp = dmp_create_object_dmp(dmp, object);
      #endif
      }
    #+END_SRC

    + Without DMP, performance penalty is extra pointer comparisons
    
    #+BEGIN_SRC c
      int object_load_field(struct object *o, int i) {
      #ifdef DMP
              if (o->dmp != NULL)
                      object_dmp_load(o->dmp, i);
      #endif
      
              return o->fields[i];
      }
    #+END_SRC

*** DMP-specific modules cont'd.

    + Each instance given an attributes record

    + Attributes contain operations table implementing DMP operations
      for that module

    + Attributes could be made object- or thread-specific
      
    #+BEGIN_SRC c
      struct object_dmp_attr {
              int owner;              /* current owner */
              int depth;              /* ownership depth used by chown() */
              struct object_dmp_ops *ops;
      };

      struct object_dmp_ops {
              int  (*load)(struct object_dmp *od, int i);        /* load object field */
              int (*store)(struct object_dmp *od, int i, int r); /* store object field */
              int (*chown)(struct object_dmp *od, int n);        /* change object owner */
      };
    #+END_SRC

    #+BEGIN_NOTES
    NULL pointer == perform default operation
    #+END_NOTES

*** Object DMP

*** Thread DMP

*** Table DMP

*** NLock DMP

*** DMP Statistics

    + With =-D=, prints DMP-related statistics on program termination

      #+BEGIN_SRC sh
        Rounds:                                 9
        
        Parallel time (seconds):         0.323777 (37.07164%)
        Serial time (seconds):           0.549605 (62.92837%)
        ============================================================
        Total time (seconds):            0.873382 (100.0%)
        
        Max parallel segment (seconds):   0.158997
        Min parallel segment (seconds):   0.000002
        Avg parallel segment (seconds):   0.071304
        
        Max serial segment (seconds):   -1.000000
        Min serial segment (seconds):    0.000378
        Avg serial segment (seconds):    0.201108
        
        Reads:                              61957 (93.77620%)
        Writes:                              4112 (6.22380%)
        ============================================================
        Total:                              66069 (100.0%)
        
        Total (shared) [?]:                 34232 (51.81250%)
        Total (private mine):               31825 (48.16934%)
        Total (private not mine) [*]:          12 (0.01816%)
        ============================================================
        Total:                              66069 (100.0%)
        
        Reads (shared):                     34224 (55.23831%)
        Reads (private mine):               27721 (44.74232%)
        Reads (private not mine) [*]:          12 (0.01937%)
        ============================================================
        Total:                              61957 (100.0%)
        
        Writes (shared) [*]:                    8 (0.19455%)
        Writes (private mine):               4104 (99.80545%)
        Writes (private not mine) [*]:          0 (0.00000%)
        ============================================================
        Total:                               4112 (100.0%)
        
        [*] Reads/writes required blocking
        [?] Writes required blocking
      #+END_SRC

*** Garbage Collection

    + Determining when a collection cycle will occur is not
      deterministic since allocations triggering a collection can
      occur during parallel mode.

    + Serial collector only, run at end of serial mode when heap is
      using =90%= or more of its available memory.

*** Performance Enhancements

    + =Integer= / =String= cache

    + Per-thread object reference cache

    + Per-thread free object cache

* Results

** Benchmarks

   + Parallel radix sort - Multithreaded radix sort

   + Jacobi - uses the Jacobi method to simulate temperature changes
     on a 20x25 plate

   + Parallel DPLL - Multithreaded boolean satisfiability using the
     DPLL algorithm
     
   #+BEGIN_NOTES
   Test test test
   #+END_NOTES

** Parameters

   + threads - 2, 4, 8 or 16 threads

   + quantum size - 1000, 10000, and 100000 instructions

   + full serial mode or reduced serial mode

   + ownership table granularity - 1, 5 and 10 depth

** Evaluation

   + overhead - measure difference in execution time when compared to
     a non-DMP virtual machine

   + measure difference in performance when parameters are changed

   Each benchmark was run 10 times for each combination of parameters.
   Run-times are averages.

** Radix

** Jacobi

** Parallel DPLL

* Conclusions

** Future Work
