#    -*- mode: org -*-
#+STARTUP: hidestars
#+STARTUP: overview
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_HLEVEL: 999
#+REVEAL_EXTRA_CSS: ./presentation.css
# Time-stamp: <08 Dec 2013 at 13:53:35 by nwidger on macros.local>

#+TITLE: Deterministic Execution in a Java-like Language
#+AUTHOR: Niels Widger
#+EMAIL: niels.widger@unh.edu

* Thesis

  A Java-like programming language can be executed deterministically
  using DMP with less overhead than a C-like programming language.

* Background

* Previous Work

** Deterministic Shared Multiprocessing (DMP)

** CoreDet

** maTe

   1. Pure OO programming language

   2. Executed in virtual machine

   3. Grammar, instruction set and machine architecture heavily based
      on Java

   4. Originally single-threaded

*** Architecture

     [[./images/vm-arch.png]]

* maTe DMP

* Implementation

** Compiler Changes

*** =synchronized= blocks

   #+BEGIN_SRC java
     synchronized (obj) { x = obj.shared; }
   #+END_SRC

*** =Real= class (=float= wrapper)
 
   #+BEGIN_SRC java  
     class Real extends Object {
             native Real();
             native Real(Real r);
             native Real(Integer i);
             native Real add(Real r);
             native Real subtract(Real r);
             native Real multiply(Real r);
             native Real divide(Real r);
             native Real greaterThan(Real r);
             native Real lessThan(Real r);
             native Real greaterThanEqual(Real r);
             native Real lessThanEqual(Real r);
             native Integer not();
             native Real minus();
             native Real operator + (Real r);
             native Real operator - (Real r);
             native Real operator * (Real r);
             native Real operator / (Real r);
             native Integer operator > (Real r);
             native Integer operator < (Real r);
             native Integer operator >= (Real r);  
             native Integer operator <= (Real r);  
             native Integer operator ! ();
             native Real operator - ();
             native Integer equals(Object obj);
             native Integer hashCode();
             native String toString();
             native Real squareRoot();
     }
   #+END_SRC
   
*** =Thread= class

   #+BEGIN_SRC java
     class Thread extends Object {
             native Thread();
             native Object start();  // begin execution of run()
             native Object run();    // overridden by subclass
             native Object join();
             native Object sleep(Integer millisec);  
     }
   #+END_SRC
   
*** =Object= class =wait= / =notify= methods

   #+BEGIN_SRC java
     class Object {
             native Object notify();
             native Object notifyAll();
             native Object wait();
             native Object wait(Integer timeout);    
     }
   #+END_SRC

** Compiler Changes cont'd

   (aka things you take for granted)

*** =for= loops
   
   #+BEGIN_SRC java
     for (i = 0; i < 10; i = i + 1) { ... }
   #+END_SRC
   
*** =&&= and =||= operators
   
   #+BEGIN_SRC java
     if ((a && b) || (c && d)) { ... }
   #+END_SRC
   
*** =!==, =<==, =>== operators
   
   #+BEGIN_SRC java
     if (a != b) { ... }
     if (a <= b) { ... }
     if (a >= b) { ... }
   #+END_SRC

** Assembler Changes

   =monitorenter= / =monitorexit= instructions

** Multithreaded Architecture

   [[./images/vm-arch-mt.png]]

** Virtual Machine Changes

*** Implementing Threads

    Each =Thread= gets its own VM stack

    Use =pthreads= threading library

    Use =pthreads_mutex_t= for object monitors

*** Implementing DMP

**** Goals

     Enable/disable *without* recompiling

     *Minimize* performance penalty when disabled

     Allow *per-object* or *per-thread* behavior

**** Design

     DMP-specific modules for =object=, =thread=, =nlock= (object
     monitor) and =table=.

     Global =dmp= module.

*** Example

#+BEGIN_SRC c
  int object_create(struct class *c, uint32_t n, struct object **o) {
  #ifdef DMP
          if (dmp == NULL)
                  object->dmp = NULL;
          else
                  object->dmp = dmp_create_object_dmp(dmp, object);
  #endif
  }
#+END_SRC

*** Object DMP

#+BEGIN_SRC c
  int object_load_field(struct object *o, int i) {
  #ifdef DMP
          if (o->dmp != NULL)
                  object_dmp_load(o->dmp, i);
  #endif
  
          return o->fields[i];
  }
#+END_SRC

*** Thread DMP

*** Table DMP

*** NLock DMP

*** DMP Statistics

*** Performance Enhancements

* Results

** Notation

** Radix

** Jacobi

** Parallel DPLL

* Conclusions

** Future Work
