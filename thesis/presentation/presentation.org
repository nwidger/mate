#    -*- mode: org -*-
#+STARTUP: hidestars
#+STARTUP: overview
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_HLEVEL: 999
#+REVEAL_EXTRA_CSS: ./presentation.css
# Time-stamp: <08 Dec 2013 at 13:53:35 by nwidger on macros.local>

#+TITLE: Deterministic Execution in a Java-like Language
#+AUTHOR: Niels Widger
#+EMAIL: niels.widger@unh.edu

* Thesis

  A Java-like programming language can be executed deterministically
  using Deterministic Shared Multiprocessing (DMP) with less overhead
  than a C-like programming language.

* Background

** Deterministic Shared Multiprocessing

   + Dynamic *run-time* enforcement of deterministic

   + Guarantees *deterministic ordering of all shared memory accesses*
     for a given input.

   + Works on *arbitrary code*

   + Do so *without* sacrificing performance

** How does it work?

   + Execute non-communicating instructions in parallel

     + Recover parallelism

     + Without interthread communication, thread interleaving does not
       affect program output

   + Serialize execution during interthread communication

   -----

   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/quantum.png]]

   #+BEGIN_NOTES
   Thread given # of instructions to execute per quantum
   Threads allowed to execute in parallel until they attempt to communicate via a communicating instruction
   Communicating instruction delayed until serial mode
   Remainder of quantum budget executed in serial mode
   #+END_NOTES

** Communicating Instructions

   + Load/store instructions to shared memory

   + Modify behavior of other threads

   + Enforce ordering of communicating instructions, others do not
     matter

** Ownership Table

   + Used to detect communicating instructions

   + Track ownership information for each memory location

     + Private - accessible only to owner

     + Shared - read-only by everyone

   + Access unrestricted in serial mode

   + Granularity - byte, word, page, etc.

   #+ATTR_HTML: :height 200%, :width 200%
   [[./images/ownershippolicy.png]]

   #+BEGIN_NOTES
   -consult ownership table before each load/store instruction
   -defer interthread comm. Via comm. Instr. Until serial mode
   -changes to ownership table happen only in serial mode
   #+END_NOTES

** Ownership Graph

   /solid == proceed immediately, dotted == block until serial mode/

   [[./images/ownership-graph.png]]

** Previous DMP Implementations
   
   + CoreDet - DMP in software
   
     + Modified LLVM compiler instruments load/store instructions
      
     + Arbitrary =C= / =C++= code
      
     + Linked with run-time framework
      
     + Ownership table stored in shared memory
      
   + *Results:* Average slowdown of 1.1x - 6x

   + Good enough for debugging, maybe for deployment!

** DMP Summary

   + Execute arbitrary code deterministically

   + Deterministic ordering of communicating instructions

   + Parallel / serial mode

   + Detect interthread communication, defer until serial mode

   + Ownership table used to detect communicating instructions

** maTe - a Java-like programming language

   1. Pure OO programming language

   2. Executed in virtual machine

   3. Grammar, instruction set and machine architecture heavily based
      on Java

   4. Originally single-threaded

** Architecture

   [[./images/vm-arch.png]]

   #+BEGIN_NOTES
   -references only == no pointers
   -method frames totally private
   -private == good == no need to instrument
   -other frames inaccessible to other frames or threads
   -no global variables â€“ object graph traversed using object fields
   #+END_NOTES

** maTe instruction set

   #+ATTR_HTML: :width 100%
   | =aconst_null= | =invokespecial= |
   | =aload=       | =invokenative=  |
   | =areturn=     | =invokevirtual= |
   | =astore=      | =new=           |
   | =checkcast=   | =newint=        |
   | =dup=         | =newstr=        |
   | =getfield=    | =out=           |
   | =goto=        | =putfield=      |
   | =ifeq=        | =refcmp=        |
   | =in=          | =return=        |

   #+BEGIN_NOTES
   Only two instructions can cause interthread communication
   Other instructions work on private op stack/local variable arrays
   #+END_NOTES

** maTe instruction set

   #+ATTR_HTML: :width 100%
   | =aconst_null= | =invokespecial= |
   | =aload=       | =invokenative=  |
   | =areturn=     | =invokevirtual= |
   | =astore=      | =new=           |
   | =checkcast=   | =newint=        |
   | =dup=         | =newstr=        |
   | *=getfield=*  | =out=           |
   | =goto=        | *=putfield=*    |
   | =ifeq=        | =refcmp=        |
   | =in=          | =return=        |

* Implementation

** Compiler Changes

   (aka things you take for granted)

   -----

   + =for= loops
   
   #+BEGIN_SRC java
     for (i = 0; i < 10; i = i + 1) { ... }
   #+END_SRC
   
   + Boolean =&&= and =||= operators
   
   #+BEGIN_SRC java
     if ((a && b) || (c && d)) { ... }
   #+END_SRC
   
   + =!==, =<==, =>== operators
   
   #+BEGIN_SRC java
     if (a != b) { ... }
     if (a <= b) { ... }
     if (a >= b) { ... }
   #+END_SRC

** Compiler Changes cont'd

*** =Real= class (=float= wrapper)
 
   #+BEGIN_SRC java  
     class Real extends Object {
             native Real();
             native Real(Real r);
             native Real(Integer i);
             native Real add(Real r);
             native Real subtract(Real r);
             native Real multiply(Real r);
             native Real divide(Real r);
             native Real greaterThan(Real r);
             native Real lessThan(Real r);
             native Real greaterThanEqual(Real r);
             native Real lessThanEqual(Real r);
             native Integer not();
             native Real minus();
             native Real operator + (Real r);
             native Real operator - (Real r);
             native Real operator * (Real r);
             native Real operator / (Real r);
             native Integer operator > (Real r);
             native Integer operator < (Real r);
             native Integer operator >= (Real r);  
             native Integer operator <= (Real r);  
             native Integer operator ! ();
             native Real operator - ();
             native Integer equals(Object obj);
             native Integer hashCode();
             native String toString();
             native Real squareRoot();
     }
   #+END_SRC

*** =synchronized= blocks

   #+BEGIN_SRC java
     for (i = 0; i < 10; i = i + 1) {
             synchronized (obj) {
                     if (obj.field != null) return obj.field;
             }
     }
   #+END_SRC

    -----

    + Use new =monitorenter= / =monitorexit= instructions

    + Monitor stack ensures necessary =monitorexit= instructions are
      executed for all execution paths.

   
*** =Thread= class

   #+BEGIN_SRC java
     class Thread extends Object {
             native Thread();
             native Object start();  // begin execution of run()
             native Object run();    // overridden by subclass
             native Object join();
             native Object sleep(Integer millisec);  
     }
   #+END_SRC

    -----

    + Java-based threading model
   
*** =Object= class =wait= / =notify= methods

   #+BEGIN_SRC java
     class Object {
             native Object notify();
             native Object notifyAll();
             native Object wait();
             native Object wait(Integer timeout);    
     }
   #+END_SRC

    -----

    + Allow notification of asynchronous events

** Virtual Machine Changes

*** Multithreaded Architecture

   [[./images/vm-arch-mt.png]]

   #+BEGIN_NOTES
   -Each thread is allocated its own PC register and VM stack
   -Share same heap
   #+END_NOTES

*** Implementing Threads

    + Each =Thread= gets its own PC register & VM stack

    + Use =pthreads= threading library

    + Use =pthreads_mutex_t= for object monitors

*** Implementing DMP

**** Goals

     Enable/disable *without* recompiling

     *Minimize* performance penalty when disabled

     Allow *per-object* or *per-thread* behavior

**** Design

     + Global =dmp= module.

     + DMP-specific modules for =object=, =thread=, =nlock= (object
       monitor) and =table=.

*** Example

    #+BEGIN_SRC c
      int object_create(struct class *c, uint32_t n, struct object **o) {
      #ifdef DMP
              if (dmp == NULL)
                      object->dmp = NULL;
              else
                      object->dmp = dmp_create_object_dmp(dmp, object);
      #endif
      }
    #+END_SRC

*** Object DMP
    
    #+BEGIN_SRC c
      int object_load_field(struct object *o, int i) {
      #ifdef DMP
              if (o->dmp != NULL)
                      object_dmp_load(o->dmp, i);
      #endif
      
              return o->fields[i];
      }
    #+END_SRC

*** Thread DMP

*** Table DMP

*** NLock DMP

*** DMP Statistics

*** Performance Enhancements

* Results

** Benchmarks

   + Parallel radix sort - Multithreaded radix sort

   + Jacobi - uses the Jacobi method to simulate temperature changes
     on a 20x25 plate

   + Parallel DPLL - Multithreaded boolean satisfiability using the
     DPLL algorithm
     
   #+BEGIN_NOTES
   Test test test
   #+END_NOTES

** Parameters

   + threads - 2, 4, 8 or 16 threads

   + quantum size - 1000, 10000, and 100000 instructions

   + full serial mode or reduced serial mode

   + ownership table granularity - 1, 5 and 10 depth

** Evaluation

   + overhead - measure difference in execution time when compared to
     a non-DMP virtual machine

   + measure difference in performance when parameters are changed

   Each benchmark was run 10 times for each combination of parameters.
   Run-times are averages.

** Radix

** Jacobi

** Parallel DPLL

* Conclusions

** Future Work
